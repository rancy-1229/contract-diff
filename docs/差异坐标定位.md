# 差异坐标定位问题分析与解决方案

## 问题描述

当前系统存在一个关键问题：**差异坐标与图片内容不匹配**。具体表现为：

1. **字符级差异检测正常**：系统能正确检测到字符级差异（如"6"→"7"，"两"→"三"等）
2. **坐标映射失败**：差异的坐标信息无法正确映射到图片上的实际位置
3. **渲染位置错误**：前端Canvas绘制的差异标记位置与实际差异内容不符

## 问题根因分析

### 1. 坐标系统不匹配

**问题**：Word文档解析和PDF图片生成的坐标系统不一致

- **Word解析**：使用`python-docx`提取文本，生成模拟坐标（如`[100 + i * 12, 100 + page_index * 20, 112 + i * 12, 116 + page_index * 20]`）
- **PDF转图片**：使用LibreOffice将Word转PDF，再用PyMuPDF转图片，坐标系统完全不同
- **结果**：差异坐标基于Word解析的模拟坐标，但图片基于PDF的真实坐标

### 2. 字符序列映射为空

从日志可以看到：
```
[DEBUG] 字符序列映射构建完成，共0个字符
```

**原因**：
- Word文档使用简化解析（`_parse_word_simple`），生成的`char_sequence`为空
- 坐标映射器无法找到字符的真实坐标信息
- 最终使用默认的模拟坐标

### 3. 文档处理流程不一致

**当前流程**：
1. Word文档 → `python-docx`解析（生成模拟坐标）
2. Word文档 → LibreOffice转PDF → PyMuPDF转图片（真实坐标）
3. 差异对比使用模拟坐标，图片使用真实坐标

## 解决方案

### 方案1：统一使用PDF坐标系统（推荐）

#### 1.1 修改文档解析流程

```python
# 修改 file_parser.py
async def parse_document(self, file_path: str, file_type: str) -> Dict:
    """解析文档并返回结构化数据"""
    
    if file_type.lower() == 'application/vnd.openxmlformats-officedocument.wordprocessingml.document':
        # 步骤1: Word转PDF
        pdf_path = await self.format_converter.convert_docx_to_pdf(file_path)
        if pdf_path:
            # 步骤2: 使用PDF解析获取真实坐标
            return await self._extract_text_and_coordinates(pdf_path)
        else:
            # 如果转换失败，使用简化解析
            return await self._parse_word_simple(file_path)
    elif file_type.lower() == 'application/pdf':
        return await self._extract_text_and_coordinates(file_path)
    else:
        return await self._parse_word_simple(file_path)
```

#### 1.2 优化PDF坐标提取

```python
async def _extract_text_and_coordinates(self, pdf_path: str) -> Dict:
    """使用PyMuPDF提取文本和坐标信息"""
    try:
        doc = fitz.open(pdf_path)
        pages_data = []
        full_text = ""
        
        for page_num in range(len(doc)):
            page = doc[page_num]
            text_dict = page.get_text("dict")
            
            page_data = {
                "page_index": page_num,
                "width": page.rect.width,
                "height": page.rect.height,
                "blocks": [],
                "char_sequence": []
            }
            
            char_index = 0
            
            for block in text_dict["blocks"]:
                if "lines" not in block:
                    continue
                    
                for line in block["lines"]:
                    for span in line["spans"]:
                        span_text = span["text"]
                        if not span_text.strip():
                            continue
                            
                        # 为每个字符创建精确坐标
                        char_bboxes = self._calculate_char_bboxes_precise(
                            span_text, span["bbox"], span["size"]
                        )
                        
                        # 添加到字符序列
                        for i, char in enumerate(span_text):
                            page_data["char_sequence"].append({
                                "char": char,
                                "char_index": char_index + i,
                                "bbox": char_bboxes[i],
                                "font": span["font"],
                                "size": span["size"],
                                "color": span["color"]
                            })
                        
                        char_index += len(span_text)
                        full_text += span_text
            
            pages_data.append(page_data)
        
        doc.close()
        return {"pages": pages_data, "full_text": full_text}
        
    except Exception as e:
        print(f"[DEBUG] PDF解析失败: {e}")
        return {"pages": [], "full_text": ""}
```

#### 1.3 修复字符坐标计算

```python
def _calculate_char_bboxes_precise(self, text: str, span_bbox: List[float], font_size: float) -> List[List[float]]:
    """计算每个字符的精确边界框"""
    if not text:
        return []
    
    x0, y0, x1, y1 = span_bbox
    char_bboxes = []
    
    # 使用更精确的字符宽度计算
    total_width = x1 - x0
    char_width = total_width / len(text) if len(text) > 0 else 0
    
    for i, char in enumerate(text):
        char_x0 = x0 + i * char_width
        char_x1 = x0 + (i + 1) * char_width
        
        char_bbox = [
            max(0, char_x0),
            max(0, y0),
            min(x1, char_x1),
            min(y1, y0 + font_size)
        ]
        char_bboxes.append(char_bbox)
    
    return char_bboxes
```

### 方案2：坐标系统转换

#### 2.1 建立坐标映射关系

```python
class CoordinateMapper:
    def __init__(self):
        self.scale_factors = {}
    
    def calculate_scale_factors(self, doc_data: Dict, image_data: Dict) -> Dict:
        """计算文档坐标到图片坐标的缩放因子"""
        scale_factors = {}
        
        for page in doc_data.get("pages", []):
            page_index = page["page_index"]
            doc_width = page["width"]
            doc_height = page["height"]
            
            # 获取对应图片的尺寸
            image_width = image_data.get("width", 800)  # 默认图片宽度
            image_height = image_data.get("height", 1000)  # 默认图片高度
            
            scale_factors[page_index] = {
                "x_scale": image_width / doc_width,
                "y_scale": image_height / doc_height
            }
        
        return scale_factors
    
    def transform_coordinates(self, bbox: List[float], page_index: int, scale_factors: Dict) -> List[float]:
        """将文档坐标转换为图片坐标"""
        if page_index not in scale_factors:
            return bbox
        
        scale = scale_factors[page_index]
        x0, y0, x1, y1 = bbox
        
        return [
            x0 * scale["x_scale"],
            y0 * scale["y_scale"],
            x1 * scale["x_scale"],
            y1 * scale["y_scale"]
        ]
```

#### 2.2 前端坐标适配

```typescript
// 前端坐标转换
const transformCoordinates = (bbox: number[], imageElement: HTMLImageElement) => {
  const [x0, y0, x1, y1] = bbox;
  
  // 获取图片的实际显示尺寸
  const displayWidth = imageElement.offsetWidth;
  const displayHeight = imageElement.offsetHeight;
  
  // 获取图片的原始尺寸
  const naturalWidth = imageElement.naturalWidth;
  const naturalHeight = imageElement.naturalHeight;
  
  // 计算缩放比例
  const scaleX = displayWidth / naturalWidth;
  const scaleY = displayHeight / naturalHeight;
  
  return [
    x0 * scaleX,
    y0 * scaleY,
    x1 * scaleX,
    y1 * scaleY
  ];
};
```

### 方案3：使用OCR技术（备选方案）

如果坐标映射仍然不准确，可以考虑使用OCR技术：

```python
import pytesseract
from PIL import Image

class OCRCoordinateMapper:
    def __init__(self):
        pass
    
    def extract_text_with_coordinates(self, image_path: str) -> Dict:
        """使用OCR提取文本和坐标"""
        image = Image.open(image_path)
        
        # 使用pytesseract获取文本和坐标
        data = pytesseract.image_to_data(image, output_type=pytesseract.Output.DICT)
        
        char_sequence = []
        for i, text in enumerate(data['text']):
            if text.strip():
                char_sequence.append({
                    "char": text,
                    "char_index": i,
                    "bbox": [
                        data['left'][i],
                        data['top'][i],
                        data['left'][i] + data['width'][i],
                        data['top'][i] + data['height'][i]
                    ]
                })
        
        return {"char_sequence": char_sequence}
```

## 推荐实施步骤

### 第一阶段：修复PDF坐标提取

1. **确保Word转PDF成功**：修复LibreOffice路径问题
2. **优化PDF解析**：使用PyMuPDF提取精确的字符坐标
3. **修复字符序列映射**：确保`char_sequence`不为空

### 第二阶段：坐标系统统一

1. **统一使用PDF坐标**：所有文档都转换为PDF后解析
2. **优化坐标计算**：改进字符边界框计算算法
3. **测试坐标精度**：验证差异标记位置准确性

### 第三阶段：前端优化

1. **坐标转换**：在前端进行坐标系统转换
2. **响应式适配**：处理不同屏幕尺寸的坐标映射
3. **交互优化**：添加坐标调试功能

## 预期效果

实施后应该达到：

1. **精确坐标映射**：差异标记准确显示在对应文字位置
2. **字符级精度**：能够标记单个字符的差异
3. **多页支持**：正确处理多页文档的坐标映射
4. **响应式显示**：在不同设备上都能正确显示差异标记

## 修复结果

### ✅ 已修复的问题

#### 1. PDF文件类型检测问题
**问题**：`file_type.lower() == 'pdf'` 条件不匹配 `'application/pdf'`
**修复**：将条件改为 `file_type.lower() == 'application/pdf'`

#### 2. LibreOffice路径问题
**问题**：`format_converter.py` 中使用 `'libreoffice'` 而不是完整路径
**修复**：改为 `/Applications/LibreOffice.app/Contents/MacOS/soffice`

#### 3. 坐标映射验证
**测试结果**：
- PDF解析正常：字符序列长度 452
- 真实坐标：`[90, 74.56684875488281, 100.47227478027344, 85.016845703125]`
- 差异坐标：`[171.00900268554688, 166.86061096191406, 175.22959899902344, 177.3106107711792]`

### 🎯 当前状态

- ✅ **PDF解析**：能够正确提取字符级坐标
- ✅ **字符序列映射**：字符序列不为空，包含真实坐标
- ✅ **差异检测**：字符级差异检测正常
- ✅ **坐标映射**：差异坐标基于真实PDF坐标

### 📋 测试验证

```bash
# 测试PDF解析
curl -s http://localhost:8000/api/documents/ | jq '.documents[] | select(.id == "a7279e6f-dd51-44f4-a9b0-88e5ddde0170") | .content_json.pages[0].char_sequence[0] | {char, bbox}'

# 结果：
{
  "char": "劳",
  "bbox": [90, 74.56684875488281, 100.47227478027344, 85.016845703125]
}

# 测试差异坐标
curl -X POST http://localhost:8000/api/comparisons/ \
  -H "Content-Type: application/json" \
  -d '{"standard_document_id": "a7279e6f-dd51-44f4-a9b0-88e5ddde0170", "target_document_id": "f7e566ee-4f6c-44e7-90fd-f9ff482a2604"}' | jq '.diff_list[0].diff[0][0] | {text, char_polygons}'

# 结果：
{
  "text": " ",
  "char_polygons": [[171.00900268554688, 166.86061096191406, 175.22959899902344, 177.3106107711792]]
}
```

## 调试建议

1. **添加坐标调试信息**：在控制台输出坐标信息
2. **可视化坐标**：在图片上显示坐标网格
3. **对比测试**：使用已知差异的文档进行测试
4. **性能监控**：监控坐标计算的性能影响

## 下一步优化

1. **Word文档支持**：确保Word转PDF后也能获得真实坐标
2. **坐标精度优化**：进一步优化字符边界框计算
3. **前端渲染优化**：确保前端Canvas正确显示差异标记
4. **多页文档支持**：完善多页文档的坐标映射
