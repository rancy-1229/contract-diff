# 合同差异对比与审查系统 - 技术架构文档 (Demo版本)

## 系统架构概览

### 整体架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用      │    │   后端API       │    │   数据库        │
│   (React)       │◄──►│   (FastAPI)     │◄──►│  (PostgreSQL)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   本地文件存储  │    │   文档处理      │    │   静态文件服务  │
│   (uploads/)    │    │   (Python)      │    │   (FastAPI)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 后端技术架构

### 1. 核心技术栈
- **Web框架：** FastAPI 0.104+
- **ORM：** SQLAlchemy 2.0+
- **数据库：** PostgreSQL 15+
- **文档处理：** Python 3.11+
- **文件存储：** 本地文件夹 (uploads/)
- **文档解析：** PyMuPDF (fitz) + python-docx
- **格式转换：** docx2pdf / LibreOffice
- **差异对比：** diff-match-patch
- **图像处理：** Pillow + OpenCV

### 2. 项目结构
```
backend/
├── app/
│   ├── __init__.py
│   ├── main.py                 # FastAPI应用入口
│   ├── config.py              # 配置管理
│   ├── database.py            # 数据库连接
│   ├── models/                # SQLAlchemy模型
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── document.py
│   │   └── comparison.py
│   ├── schemas/               # Pydantic模型
│   │   ├── __init__.py
│   │   ├── user.py
│   │   ├── document.py
│   │   └── comparison.py
│   ├── api/                   # API路由
│   │   ├── __init__.py
│   │   ├── auth.py
│   │   ├── documents.py
│   │   └── comparisons.py
│   ├── services/              # 业务逻辑层
│   │   ├── __init__.py
│   │   ├── auth_service.py
│   │   ├── document_service.py
│   │   └── comparison_service.py
│   └── utils/                 # 工具函数
│       ├── __init__.py
│       ├── file_parser.py     # 文档解析
│       ├── format_converter.py # 格式转换
│       ├── diff_engine.py     # 差异对比
│       ├── coordinate_mapper.py # 坐标映射
│       └── image_processor.py # 图像处理
├── uploads/                   # 本地文件存储
│   ├── documents/             # 原始文档
│   ├── images/                # 生成的图片
│   └── temp/                  # 临时文件
├── tests/                     # 测试文件
├── requirements.txt           # Python依赖
└── Dockerfile                # Docker配置
```

### 3. 数据库设计

#### 3.1 核心表结构 (Demo版本)

**文档表 (documents)**
```sql
CREATE TABLE documents (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    filename VARCHAR(255) NOT NULL,
    original_filename VARCHAR(255) NOT NULL,
    file_path VARCHAR(500) NOT NULL,
    file_size BIGINT NOT NULL,
    file_type VARCHAR(50) NOT NULL,
    document_type VARCHAR(20) NOT NULL, -- 'standard' or 'target'
    status VARCHAR(20) DEFAULT 'uploaded', -- 'uploaded', 'processing', 'processed', 'failed'
    content_text TEXT,
    content_json JSONB,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**对比任务表 (comparisons)**
```sql
CREATE TABLE comparisons (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    standard_document_id UUID REFERENCES documents(id),
    target_document_id UUID REFERENCES documents(id),
    status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'processing', 'completed', 'failed'
    progress INTEGER DEFAULT 0,
    result_json JSONB,
    differences_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP
);
```

### 4. API设计

#### 4.1 文档上传接口
```python
# app/api/documents.py
from fastapi import APIRouter, UploadFile, File, HTTPException
from app.services.document_service import DocumentService
from app.utils.file_parser import DocumentParser
import os
import uuid
from datetime import datetime

router = APIRouter(prefix="/api/documents", tags=["documents"])

@router.post("/upload")
async def upload_document(
    file: UploadFile = File(...),
    document_type: str = "standard"  # "standard" or "target"
):
    """上传文档"""
    # 验证文件类型
    allowed_types = ["application/pdf", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"]
    if file.content_type not in allowed_types:
        raise HTTPException(status_code=400, detail="只支持 PDF 和 Word 格式文件")
    
    # 验证文件大小 (50MB)
    max_size = 50 * 1024 * 1024
    content = await file.read()
    if len(content) > max_size:
        raise HTTPException(status_code=400, detail="文件大小不能超过 50MB")
    
    # 生成唯一文件名
    file_extension = os.path.splitext(file.filename)[1]
    unique_filename = f"{uuid.uuid4()}{file_extension}"
    
    # 保存文件到本地
    file_path = f"uploads/documents/{document_type}/{unique_filename}"
    os.makedirs(os.path.dirname(file_path), exist_ok=True)
    
    with open(file_path, "wb") as buffer:
        buffer.write(content)
    
    # 解析文档
    try:
        parser = DocumentParser()
        parsed_data = await parser.parse_document(file_path, file.content_type)
        
        # 保存到数据库
        document = await DocumentService.create_document({
            "filename": unique_filename,
            "original_filename": file.filename,
            "file_path": file_path,
            "file_size": len(content),
            "file_type": file.content_type,
            "document_type": document_type,
            "content_json": parsed_data,
            "status": "processed"
        })
        
        return {
            "document_id": str(document.id),
            "filename": file.filename,
            "document_type": document_type,
            "status": "uploaded",
            "file_size": len(content)
        }
        
    except Exception as e:
        # 删除已上传的文件
        if os.path.exists(file_path):
            os.remove(file_path)
        raise HTTPException(status_code=500, detail=f"文档处理失败: {str(e)}")

@router.get("/")
async def list_documents():
    """获取文档列表"""
    documents = await DocumentService.list_documents()
    return documents

@router.get("/{document_id}")
async def get_document(document_id: str):
    """获取文档信息"""
    document = await DocumentService.get_document(document_id)
    if not document:
        raise HTTPException(status_code=404, detail="文档不存在")
    return document

@router.delete("/{document_id}")
async def delete_document(document_id: str):
    """删除文档"""
    document = await DocumentService.get_document(document_id)
    if not document:
        raise HTTPException(status_code=404, detail="文档不存在")
    
    # 删除文件
    if os.path.exists(document.file_path):
        os.remove(document.file_path)
    
    # 删除数据库记录
    await DocumentService.delete_document(document_id)
    
    return {"message": "文档删除成功"}
```

#### 4.2 文档对比接口
```python
# app/api/comparisons.py
from fastapi import APIRouter, HTTPException
from app.services.comparison_service import ComparisonService
from app.services.document_service import DocumentService
from app.utils.diff_engine import DiffEngine
from app.utils.image_processor import ImageProcessor

router = APIRouter(prefix="/api/comparisons", tags=["comparisons"])

@router.post("/")
async def create_comparison(
    standard_document_id: str,
    target_document_id: str
):
    """创建文档对比任务"""
    # 获取文档信息
    standard_doc = await DocumentService.get_document(standard_document_id)
    target_doc = await DocumentService.get_document(target_document_id)
    
    if not standard_doc or not target_doc:
        raise HTTPException(status_code=404, detail="文档不存在")
    
    if standard_doc.status != "processed" or target_doc.status != "processed":
        raise HTTPException(status_code=400, detail="文档尚未处理完成")
    
    try:
        # 执行差异对比
        diff_engine = DiffEngine()
        comparison_result = await diff_engine.compare_documents(
            standard_doc.content_json,
            target_doc.content_json
        )
        
        # 生成对比图片
        image_processor = ImageProcessor()
        images = await image_processor.generate_comparison_images(
            standard_doc.file_path,
            target_doc.file_path,
            f"comp_{standard_document_id}_{target_document_id}"
        )
        
        # 保存对比结果
        comparison = await ComparisonService.create_comparison({
            "standard_document_id": standard_document_id,
            "target_document_id": target_document_id,
            "result_json": comparison_result,
            "status": "completed",
            "differences_count": len(comparison_result["diff_list"])
        })
        
        return {
            "comparison_id": str(comparison.id),
            "standard_images": images["standard_images"],
            "target_images": images["target_images"],
            "diff_list": comparison_result["diff_list"],
            "summary": comparison_result["summary"]
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"对比处理失败: {str(e)}")

@router.get("/")
async def list_comparisons():
    """获取对比任务列表"""
    comparisons = await ComparisonService.list_comparisons()
    return comparisons

@router.get("/{comparison_id}")
async def get_comparison_result(comparison_id: str):
    """获取对比结果"""
    comparison = await ComparisonService.get_comparison(comparison_id)
    if not comparison:
        raise HTTPException(status_code=404, detail="对比任务不存在")
    
    return {
        "comparison_id": str(comparison.id),
        "standard_document_id": str(comparison.standard_document_id),
        "target_document_id": str(comparison.target_document_id),
        "status": comparison.status,
        "diff_list": comparison.result_json["diff_list"],
        "summary": comparison.result_json["summary"],
        "created_at": comparison.created_at
    }
```

#### 4.3 静态文件服务
```python
# app/main.py
from fastapi import FastAPI
from fastapi.staticfiles import StaticFiles
from fastapi.middleware.cors import CORSMiddleware

app = FastAPI(title="合同差异对比系统", version="1.0.0")

# CORS配置
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000"],  # 前端地址
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# 静态文件服务
app.mount("/images", StaticFiles(directory="uploads/images"), name="images")
app.mount("/documents", StaticFiles(directory="uploads/documents"), name="documents")

# 注册路由
app.include_router(documents_router)
app.include_router(comparisons_router)
```

### 5. 核心服务实现

#### 5.1 文档解析服务
```python
# app/utils/file_parser.py
import fitz  # PyMuPDF
from docx import Document
import json
import os
from typing import Dict, List, Tuple
from .format_converter import FormatConverter
from .coordinate_mapper import CoordinateMapper

class DocumentParser:
    def __init__(self):
        self.upload_dir = "uploads/documents"
        self.image_dir = "uploads/images"
        self.temp_dir = "uploads/temp"
        self.format_converter = FormatConverter()
        self.coordinate_mapper = CoordinateMapper()
        
        # 确保目录存在
        for dir_path in [self.upload_dir, self.image_dir, self.temp_dir]:
            os.makedirs(dir_path, exist_ok=True)
    
    async def parse_document(self, file_path: str, file_type: str) -> Dict:
        """解析文档并返回结构化数据"""
        # Step 1: 统一格式转换
        pdf_path = await self._ensure_pdf_format(file_path, file_type)
        
        # Step 2: 文本与坐标提取
        parsed_data = await self._extract_text_and_coordinates(pdf_path)
        
        # Step 3: 生成字符序列索引表
        char_index_map = self.coordinate_mapper.build_char_index_map(parsed_data)
        
        return {
            "pages": parsed_data["pages"],
            "char_index_map": char_index_map,
            "full_text": parsed_data["full_text"],
            "pdf_path": pdf_path
        }
    
    async def _ensure_pdf_format(self, file_path: str, file_type: str) -> str:
        """确保文档为PDF格式"""
        if file_type.lower() == 'pdf':
            return file_path
        elif file_type.lower() in ['docx', 'doc']:
            # 转换Word文档为PDF
            pdf_path = await self.format_converter.docx_to_pdf(file_path)
            return pdf_path
        else:
            raise ValueError(f"Unsupported file type: {file_type}")
    
    async def _extract_text_and_coordinates(self, pdf_path: str) -> Dict:
        """使用PyMuPDF提取文本和坐标信息"""
        doc = fitz.open(pdf_path)
        pages_data = []
        full_text = ""
        
        for page_num in range(len(doc)):
            page = doc[page_num]
            
            # 获取页面文本和坐标信息
            text_dict = page.get_text("dict")
            page_data = {
                "page_index": page_num,
                "width": page.rect.width,
                "height": page.rect.height,
                "blocks": [],
                "char_sequence": []  # 字符序列，用于坐标映射
            }
            
            char_index = 0
            
            for block in text_dict["blocks"]:
                if "lines" in block:
                    block_data = {
                        "block_index": len(page_data["blocks"]),
                        "lines": []
                    }
                    
                    for line in block["lines"]:
                        line_data = {
                            "line_index": len(block_data["lines"]),
                            "bbox": line["bbox"],  # [x0, y0, x1, y1]
                            "spans": []
                        }
                        
                        for span in line["spans"]:
                            span_data = {
                                "text": span["text"],
                                "bbox": span["bbox"],
                                "font": span["font"],
                                "size": span["size"],
                                "flags": span["flags"],
                                "color": span["color"],
                                "char_start_index": char_index,
                                "char_end_index": char_index + len(span["text"])
                            }
                            
                            # 为每个字符创建坐标信息
                            char_bboxes = self._calculate_char_bboxes(
                                span["text"], 
                                span["bbox"], 
                                span["size"]
                            )
                            
                            span_data["char_bboxes"] = char_bboxes
                            line_data["spans"].append(span_data)
                            
                            # 更新字符序列
                            for i, char in enumerate(span["text"]):
                                page_data["char_sequence"].append({
                                    "char": char,
                                    "char_index": char_index + i,
                                    "bbox": char_bboxes[i] if i < len(char_bboxes) else span["bbox"],
                                    "font": span["font"],
                                    "size": span["size"],
                                    "color": span["color"]
                                })
                            
                            char_index += len(span["text"])
                            full_text += span["text"]
                        
                        block_data["lines"].append(line_data)
                    
                    page_data["blocks"].append(block_data)
            
            pages_data.append(page_data)
        
        doc.close()
        return {
            "pages": pages_data,
            "full_text": full_text
        }
    
    def _calculate_char_bboxes(self, text: str, span_bbox: List[float], font_size: float) -> List[List[float]]:
        """计算每个字符的边界框"""
        if not text:
            return []
        
        x0, y0, x1, y1 = span_bbox
        char_width = (x1 - x0) / len(text)
        char_bboxes = []
        
        for i, char in enumerate(text):
            char_x0 = x0 + i * char_width
            char_x1 = x0 + (i + 1) * char_width
            char_bboxes.append([char_x0, y0, char_x1, y1])
        
        return char_bboxes
```

#### 5.2 格式转换服务
```python
# app/utils/format_converter.py
import subprocess
import os
from typing import Optional
import asyncio

class FormatConverter:
    def __init__(self):
        self.temp_dir = "uploads/temp"
        os.makedirs(self.temp_dir, exist_ok=True)
    
    async def docx_to_pdf(self, docx_path: str) -> str:
        """将Word文档转换为PDF"""
        # 生成PDF路径
        base_name = os.path.splitext(os.path.basename(docx_path))[0]
        pdf_path = os.path.join(self.temp_dir, f"{base_name}.pdf")
        
        try:
            # 方法1: 使用docx2pdf (推荐，跨平台)
            await self._convert_with_docx2pdf(docx_path, pdf_path)
        except Exception as e:
            print(f"docx2pdf failed: {e}")
            try:
                # 方法2: 使用LibreOffice (备选方案)
                await self._convert_with_libreoffice(docx_path, pdf_path)
            except Exception as e2:
                print(f"LibreOffice conversion failed: {e2}")
                raise Exception("All conversion methods failed")
        
        return pdf_path
    
    async def _convert_with_docx2pdf(self, docx_path: str, pdf_path: str):
        """使用docx2pdf库转换"""
        try:
            from docx2pdf import convert
            # 在异步环境中运行同步函数
            loop = asyncio.get_event_loop()
            await loop.run_in_executor(None, convert, docx_path, pdf_path)
        except ImportError:
            raise Exception("docx2pdf library not installed")
    
    async def _convert_with_libreoffice(self, docx_path: str, pdf_path: str):
        """使用LibreOffice命令行转换"""
        cmd = [
            "libreoffice",
            "--headless",
            "--convert-to", "pdf",
            "--outdir", self.temp_dir,
            docx_path
        ]
        
        process = await asyncio.create_subprocess_exec(
            *cmd,
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode != 0:
            raise Exception(f"LibreOffice conversion failed: {stderr.decode()}")
        
        # 检查输出文件是否存在
        if not os.path.exists(pdf_path):
            raise Exception("PDF file was not created")
```

#### 5.3 坐标映射服务
```python
# app/utils/coordinate_mapper.py
from typing import Dict, List, Tuple, Optional

class CoordinateMapper:
    def __init__(self):
        pass
    
    def build_char_index_map(self, parsed_data: Dict) -> Dict:
        """构建字符序列到坐标的索引映射"""
        char_index_map = {
            "char_to_coords": {},  # 字符索引 -> 坐标信息
            "coords_to_char": {},  # 坐标信息 -> 字符索引
            "page_char_ranges": {}  # 每页的字符范围
        }
        
        char_index = 0
        
        for page_data in parsed_data["pages"]:
            page_index = page_data["page_index"]
            page_char_start = char_index
            
            for char_info in page_data["char_sequence"]:
                char_index_map["char_to_coords"][char_index] = {
                    "page_index": page_index,
                    "bbox": char_info["bbox"],
                    "font": char_info["font"],
                    "size": char_info["size"],
                    "color": char_info["color"]
                }
                
                # 坐标到字符的反向映射
                bbox_key = f"{page_index}_{char_info['bbox']}"
                char_index_map["coords_to_char"][bbox_key] = char_index
                
                char_index += 1
            
            page_char_end = char_index - 1
            char_index_map["page_char_ranges"][page_index] = {
                "start": page_char_start,
                "end": page_char_end
            }
        
        return char_index_map
    
    def map_diff_to_coordinates(self, diff_result: List, char_index_map: Dict) -> List[Dict]:
        """将差异结果映射到坐标信息"""
        mapped_diffs = []
        
        for diff in diff_result:
            if diff["type"] == "text":
                # 获取差异文本的字符索引范围
                char_start = diff.get("char_start", 0)
                char_end = diff.get("char_end", char_start + 1)
                
                # 查找对应的坐标信息
                coordinates = []
                for char_idx in range(char_start, char_end):
                    if char_idx in char_index_map["char_to_coords"]:
                        coord_info = char_index_map["char_to_coords"][char_idx]
                        coordinates.append({
                            "char_index": char_idx,
                            "page_index": coord_info["page_index"],
                            "bbox": coord_info["bbox"],
                            "font": coord_info["font"],
                            "size": coord_info["size"],
                            "color": coord_info["color"]
                        })
                
                mapped_diff = {
                    "element_id": diff["element_id"],
                    "type": diff["type"],
                    "status": diff["status"],
                    "elements": diff["elements"],
                    "char_start": char_start,
                    "char_end": char_end,
                    "coordinates": coordinates
                }
                
                mapped_diffs.append(mapped_diff)
        
        return mapped_diffs
```

#### 5.4 差异对比服务
```python
# app/utils/diff_engine.py
import diff_match_patch as dmp_module
from typing import List, Dict, Any
from .coordinate_mapper import CoordinateMapper

class DiffEngine:
    def __init__(self):
        self.dmp = dmp_module.diff_match_patch()
        self.coordinate_mapper = CoordinateMapper()
        self.colors = {
            "ADD": "#90EE90",      # 浅绿色 - 新增
            "DELETE": "#FFB6C1",   # 浅红色 - 删除
            "CHANGE": "#FFFF99",   # 浅黄色 - 修改
            "MOVE": "#87CEEB"      # 浅蓝色 - 移动
        }
    
    async def compare_documents(self, standard_data: Dict, target_data: Dict) -> Dict:
        """对比两个文档并返回差异信息"""
        # Step 3: 文本对比
        diff_result = await self._compare_texts(
            standard_data["full_text"], 
            target_data["full_text"]
        )
        
        # Step 4: 坐标映射
        mapped_diffs = self._map_diffs_to_coordinates(
            diff_result, 
            standard_data["char_index_map"],
            target_data["char_index_map"]
        )
        
        return {
            "diff_list": mapped_diffs,
            "summary": self.generate_summary(mapped_diffs)
        }
    
    async def _compare_texts(self, text1: str, text2: str) -> List[Dict]:
        """使用diff-match-patch进行文本对比"""
        # 计算差异
        diffs = self.dmp.diff_main(text1, text2)
        self.dmp.diff_cleanupSemantic(diffs)
        
        # 转换为标准格式
        diff_result = []
        char_index = 0
        
        for diff_type, diff_text in diffs:
            if diff_type == 0:  # 相同内容
                char_index += len(diff_text)
                continue
            elif diff_type == -1:  # 删除
                status = "DELETE"
                doc_index = 1  # 标准文档
            elif diff_type == 1:  # 新增
                status = "ADD"
                doc_index = 2  # 目标文档
            
            diff_item = {
                "element_id": f"diff_{len(diff_result)}",
                "type": "text",
                "status": status,
                "elements": f'["{diff_text}"]',
                "text": diff_text,
                "char_start": char_index,
                "char_end": char_index + len(diff_text),
                "doc_index": doc_index
            }
            
            diff_result.append(diff_item)
            
            if diff_type == -1:  # 删除内容不增加索引
                continue
            else:
                char_index += len(diff_text)
        
        return diff_result
    
    def _map_diffs_to_coordinates(self, diff_result: List[Dict], 
                                standard_char_map: Dict, 
                                target_char_map: Dict) -> List[Dict]:
        """将差异结果映射到坐标信息"""
        mapped_diffs = []
        
        for diff in diff_result:
            if diff["status"] == "DELETE":
                # 删除内容映射到标准文档的坐标
                coordinates = self._get_coordinates_for_text(
                    diff["char_start"], 
                    diff["char_end"], 
                    standard_char_map
                )
                doc_index = 1
            elif diff["status"] == "ADD":
                # 新增内容映射到目标文档的坐标
                coordinates = self._get_coordinates_for_text(
                    diff["char_start"], 
                    diff["char_end"], 
                    target_char_map
                )
                doc_index = 2
            
            # 生成符合前端要求的格式
            diff_item = {
                "element_id": diff["element_id"],
                "type": diff["type"],
                "status": diff["status"],
                "page_index": coordinates[0]["page_index"] if coordinates else 0,
                "elements": diff["elements"],
                "diff": self._format_coordinates_for_frontend(coordinates, doc_index)
            }
            
            mapped_diffs.append(diff_item)
        
        return mapped_diffs
    
    def _get_coordinates_for_text(self, char_start: int, char_end: int, char_map: Dict) -> List[Dict]:
        """获取文本对应的坐标信息"""
        coordinates = []
        
        for char_idx in range(char_start, char_end):
            if char_idx in char_map["char_to_coords"]:
                coord_info = char_map["char_to_coords"][char_idx]
                coordinates.append({
                    "char_index": char_idx,
                    "page_index": coord_info["page_index"],
                    "bbox": coord_info["bbox"],
                    "font": coord_info["font"],
                    "size": coord_info["size"],
                    "color": coord_info["color"]
                })
        
        return coordinates
    
    def _format_coordinates_for_frontend(self, coordinates: List[Dict], doc_index: int) -> List[List[Dict]]:
        """格式化为前端需要的坐标格式"""
        formatted_diffs = []
        
        for coord in coordinates:
            char_info = {
                "text": "",  # 这里可以添加实际字符
                "page_index": coord["page_index"],
                "line_index": 0,  # 可以从坐标计算
                "doc_index": doc_index,
                "char_polygons": [coord["bbox"]],
                "polygon": [0, 0, 0, 0, 0, 0, 0, 0],
                "sub_info": [{
                    "page_id": coord["page_index"],
                    "sub_polygons": coord["bbox"],
                    "sub_text_index": {
                        "start_index": coord["char_index"],
                        "length": 1
                    }
                }],
                "sub_type": ""
            }
            formatted_diffs.append([char_info])
        
        return formatted_diffs
    
    def generate_summary(self, diff_list: List[Dict]) -> Dict:
        """生成差异摘要"""
        summary = {
            "total_differences": len(diff_list),
            "additions": len([d for d in diff_list if d["status"] == "ADD"]),
            "deletions": len([d for d in diff_list if d["status"] == "DELETE"]),
            "changes": len([d for d in diff_list if d["status"] == "CHANGE"]),
            "moves": len([d for d in diff_list if d["status"] == "MOVE"])
        }
        return summary
```

#### 5.5 图像处理服务
```python
# app/utils/image_processor.py
from PIL import Image, ImageDraw, ImageFont
import fitz
import os
from typing import Dict, List

class ImageProcessor:
    def __init__(self):
        self.image_dir = "uploads/images"
        os.makedirs(self.image_dir, exist_ok=True)
    
    async def generate_comparison_images(self, standard_pdf_path: str, target_pdf_path: str, comparison_id: str) -> Dict:
        """生成对比图片"""
        # Step 5: 生成PNG图片
        standard_images = await self.pdf_to_images(standard_pdf_path, f"{comparison_id}_standard")
        target_images = await self.pdf_to_images(target_pdf_path, f"{comparison_id}_target")
        
        return {
            "standard_images": standard_images,
            "target_images": target_images
        }
    
    async def pdf_to_images(self, pdf_path: str, image_prefix: str) -> List[str]:
        """将PDF转换为图片"""
        doc = fitz.open(pdf_path)
        image_paths = []
        
        for page_num in range(len(doc)):
            page = doc[page_num]
            
            # 设置缩放比例以提高图片质量
            mat = fitz.Matrix(2.0, 2.0)  # 2倍缩放
            pix = page.get_pixmap(matrix=mat)
            
            # 生成图片文件名
            image_filename = f"{image_prefix}_page_{page_num}.png"
            image_path = os.path.join(self.image_dir, image_filename)
            
            # 保存图片
            pix.save(image_path)
            image_paths.append(f"/images/{image_filename}")
        
        doc.close()
        return image_paths
    
    async def add_diff_overlays(self, image_path: str, diff_list: List[Dict], output_path: str):
        """在图片上添加差异标记（可选功能）"""
        # 打开原始图片
        image = Image.open(image_path)
        
        # 创建RGBA模式以支持透明度
        if image.mode != 'RGBA':
            image = image.convert('RGBA')
        
        # 创建绘制对象
        overlay = Image.new('RGBA', image.size, (255, 255, 255, 0))
        draw = ImageDraw.Draw(overlay)
        
        # 定义颜色
        colors = {
            "ADD": (144, 238, 144, 100),      # 浅绿色 - 新增
            "DELETE": (255, 182, 193, 100),   # 浅红色 - 删除  
            "CHANGE": (255, 255, 153, 100),   # 浅黄色 - 修改
            "MOVE": (135, 206, 235, 100)      # 浅蓝色 - 移动
        }
        
        # 绘制差异标记
        for diff in diff_list:
            if diff["type"] == "text" and "diff" in diff:
                color = colors.get(diff["status"], (255, 255, 255, 100))
                
                for char_group in diff["diff"]:
                    for char_info in char_group:
                        if "char_polygons" in char_info:
                            for polygon in char_info["char_polygons"]:
                                # 绘制半透明矩形
                                x0, y0, x1, y1 = polygon
                                draw.rectangle([x0, y0, x1, y1], fill=color)
                                
                                # 绘制边框
                                draw.rectangle([x0, y0, x1, y1], outline=color[:3], width=1)
        
        # 合并图片
        result = Image.alpha_composite(image, overlay)
        
        # 转换回RGB模式并保存
        result = result.convert('RGB')
        result.save(output_path)
        
        return output_path
    
    async def generate_diff_images_with_overlays(self, pdf_path: str, diff_list: List[Dict], 
                                               image_prefix: str) -> List[str]:
        """生成带差异标记的图片"""
        # 首先生成原始图片
        original_images = await self.pdf_to_images(pdf_path, f"{image_prefix}_original")
        
        # 为每页生成带标记的图片
        marked_images = []
        doc = fitz.open(pdf_path)
        
        for page_num in range(len(doc)):
            # 获取当前页的差异
            page_diffs = [diff for diff in diff_list if diff.get("page_index") == page_num]
            
            if page_diffs:
                # 生成带标记的图片
                original_image_path = original_images[page_num].replace("/images/", f"{self.image_dir}/")
                marked_image_path = original_image_path.replace("_original_", "_marked_")
                
                await self.add_diff_overlays(original_image_path, page_diffs, marked_image_path)
                marked_images.append(f"/images/{os.path.basename(marked_image_path)}")
            else:
                # 没有差异，使用原始图片
                marked_images.append(original_images[page_num])
        
        doc.close()
        return marked_images
```

### 6. 完整处理流程

#### 6.1 文档处理流程
```
docx/pdf 文档
    │
    ├── [Step 1] 统一格式：docx 转 pdf
    │   ├── docx2pdf (推荐)
    │   └── LibreOffice (备选)
    │
    ├── [Step 2] 文本+坐标提取（PyMuPDF）
    │   ├── 提取页面结构
    │   ├── 提取字符级坐标
    │   └── 生成字符序列索引表
    │
    ├── [Step 3] 文本对比（diff-match-patch）
    │   ├── 字符级差异检测
    │   ├── 语义清理
    │   └── 差异分类
    │
    ├── [Step 4] 坐标映射
    │   ├── 差异文本 → 字符索引
    │   ├── 字符索引 → 坐标信息
    │   └── 生成前端格式
    │
    └── [Step 5] 生成输出
            ├── PNG（原始 PDF 渲染成图片）
            └── JSON（差异列表+坐标）
```

#### 6.2 核心数据结构
```python
# 文档解析结果
{
    "pages": [
        {
            "page_index": 0,
            "width": 612,
            "height": 792,
            "blocks": [...],
            "char_sequence": [
                {
                    "char": "字",
                    "char_index": 0,
                    "bbox": [100, 100, 112, 116],
                    "font": "Arial",
                    "size": 12,
                    "color": 0
                }
            ]
        }
    ],
    "char_index_map": {
        "char_to_coords": {0: {...}},
        "coords_to_char": {...},
        "page_char_ranges": {...}
    },
    "full_text": "完整文本内容",
    "pdf_path": "转换后的PDF路径"
}

# 差异对比结果
{
    "diff_list": [
        {
            "element_id": "diff_0",
            "type": "text",
            "status": "CHANGE",
            "page_index": 0,
            "elements": "[\"修改内容\"]",
            "diff": [
                [
                    {
                        "text": "字",
                        "page_index": 0,
                        "line_index": 4,
                        "doc_index": 1,
                        "char_polygons": [[1218, 506, 1246, 506, 1246, 534, 1218, 535]],
                        "polygon": [0, 0, 0, 0, 0, 0, 0, 0],
                        "sub_info": [...],
                        "sub_type": ""
                    }
                ]
            ]
        }
    ],
    "summary": {
        "total_differences": 1,
        "additions": 0,
        "deletions": 0,
        "changes": 1,
        "moves": 0
    }
}
```

#### 6.3 依赖包列表
```txt
# requirements.txt
fastapi==0.104.1
uvicorn==0.24.0
sqlalchemy==2.0.23
psycopg2-binary==2.9.9
pydantic==2.5.0
python-multipart==0.0.6

# 文档处理
PyMuPDF==1.23.8
python-docx==1.1.0
docx2pdf==0.1.8

# 差异对比
diff-match-patch==20230430

# 图像处理
Pillow==10.1.0
opencv-python==4.8.1.78

# 其他工具
aiofiles==23.2.1
python-jose[cryptography]==3.3.0
passlib[bcrypt]==1.7.4
```

## 前端技术架构

### 1. 核心技术栈
- **框架：** React 18+
- **状态管理：** Redux Toolkit
- **UI组件库：** Ant Design
- **构建工具：** Vite
- **类型检查：** TypeScript
- **HTTP客户端：** Axios
- **路由：** React Router
- **图像处理：** Canvas API

### 2. 项目结构 (React版本)
```
frontend/
├── public/
├── src/
│   ├── components/            # 通用组件
│   │   ├── common/
│   │   │   ├── Header.tsx
│   │   │   ├── Sidebar.tsx
│   │   │   └── Loading.tsx
│   │   ├── document/
│   │   │   ├── DocumentUpload.tsx
│   │   │   ├── DocumentList.tsx
│   │   │   └── DocumentViewer.tsx
│   │   ├── comparison/
│   │   │   ├── ComparisonForm.tsx
│   │   │   ├── ComparisonResult.tsx
│   │   │   └── DiffViewer.tsx
│   │   └── review/
│   │       ├── ReviewEditor.tsx
│   │       ├── ReviewList.tsx
│   │       └── ReportGenerator.tsx
│   ├── pages/                # 页面组件
│   │   ├── Login.tsx
│   │   ├── Dashboard.tsx
│   │   ├── Documents.tsx
│   │   ├── Comparisons.tsx
│   │   └── Reviews.tsx
│   ├── hooks/                # 自定义Hooks
│   │   ├── useAuth.ts
│   │   ├── useDocuments.ts
│   │   └── useComparisons.ts
│   ├── services/             # API服务
│   │   ├── api.ts
│   │   ├── auth.ts
│   │   ├── documents.ts
│   │   └── comparisons.ts
│   ├── store/                # 状态管理
│   │   ├── index.ts
│   │   ├── authSlice.ts
│   │   ├── documentSlice.ts
│   │   └── comparisonSlice.ts
│   ├── utils/                # 工具函数
│   │   ├── constants.ts
│   │   ├── helpers.ts
│   │   └── validators.ts
│   ├── types/                # TypeScript类型
│   │   ├── auth.ts
│   │   ├── document.ts
│   │   └── comparison.ts
│   ├── styles/               # 样式文件
│   │   ├── globals.css
│   │   └── components.css
│   ├── App.tsx
│   └── main.tsx
├── package.json
├── tsconfig.json
├── vite.config.ts
└── tailwind.config.js
```

### 3. 核心组件设计

#### 3.1 文档上传组件
```typescript
// src/components/document/DocumentUpload.tsx
import { Upload, message } from 'antd';
import { InboxOutlined } from '@ant-design/icons';

interface DocumentUploadProps {
  onUpload: (files: File[]) => void;
  documentType: 'standard' | 'target';
}

const DocumentUpload: React.FC<DocumentUploadProps> = ({ onUpload, documentType }) => {
  const handleUpload = (file: File) => {
    const isValidType = file.type === 'application/pdf' || 
                       file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    
    if (!isValidType) {
      message.error('只支持 PDF 和 Word 格式文件');
      return false;
    }
    
    onUpload([file]);
    return false; // 阻止自动上传
  };
  
  return (
    <div className="upload-container">
      <Upload.Dragger
        name="file"
        multiple={false}
        accept=".pdf,.docx,.doc"
        beforeUpload={handleUpload}
        showUploadList={false}
      >
        <p className="ant-upload-drag-icon">
          <InboxOutlined />
        </p>
        <p className="ant-upload-text">
          点击或拖拽文件到此区域上传{documentType === 'standard' ? '标准文档' : '待审核文档'}
        </p>
        <p className="ant-upload-hint">
          支持 PDF、Word 格式文件，文件大小不超过 50MB
        </p>
      </Upload.Dragger>
    </div>
  );
};
```

#### 3.2 差异对比展示组件
```typescript
// src/components/comparison/DiffViewer.tsx
import React, { useRef, useEffect, useState } from 'react';
import { Card, Row, Col, Tag, List, Typography } from 'antd';

const { Title, Text } = Typography;

interface DiffItem {
  element_id: string;
  type: string;
  status: 'ADD' | 'DELETE' | 'CHANGE' | 'MOVE';
  page_index: number;
  elements: string;
  diff: Array<Array<{
    text: string;
    page_index: number;
    line_index: number;
    doc_index: number;
    char_polygons: number[][];
    polygon: number[];
    sub_info: Array<{
      page_id: number;
      sub_polygons: number[];
      sub_text_index: {
        start_index: number;
        length: number;
      };
    }>;
    sub_type: string;
  }>>;
}

interface DiffViewerProps {
  standardImage: string;
  targetImage: string;
  diffList: DiffItem[];
  summary: {
    total_differences: number;
    additions: number;
    deletions: number;
    changes: number;
    moves: number;
  };
}

const DiffViewer: React.FC<DiffViewerProps> = ({ 
  standardImage, 
  targetImage, 
  diffList, 
  summary 
}) => {
  const standardCanvasRef = useRef<HTMLCanvasElement>(null);
  const targetCanvasRef = useRef<HTMLCanvasElement>(null);
  const [selectedDiff, setSelectedDiff] = useState<DiffItem | null>(null);

  const statusColors = {
    ADD: '#52c41a',      // 绿色 - 新增
    DELETE: '#ff4d4f',   // 红色 - 删除
    CHANGE: '#faad14',   // 橙色 - 修改
    MOVE: '#1890ff'      // 蓝色 - 移动
  };

  const statusLabels = {
    ADD: '新增',
    DELETE: '删除', 
    CHANGE: '修改',
    MOVE: '移动'
  };

  useEffect(() => {
    if (standardImage && targetImage) {
      loadImagesAndDrawDiffs();
    }
  }, [standardImage, targetImage, diffList]);

  const loadImagesAndDrawDiffs = async () => {
    await Promise.all([
      drawImageWithDiffs(standardCanvasRef.current!, standardImage, 1),
      drawImageWithDiffs(targetCanvasRef.current!, targetImage, 2)
    ]);
  };

  const drawImageWithDiffs = async (canvas: HTMLCanvasElement, imageSrc: string, docIndex: number) => {
    const ctx = canvas.getContext('2d')!;
    const img = new Image();
    
    img.onload = () => {
      // 设置canvas尺寸
      canvas.width = img.width;
      canvas.height = img.height;
      
      // 绘制原始图片
      ctx.drawImage(img, 0, 0);
      
      // 绘制差异标记
      drawDiffOverlays(ctx, docIndex);
    };
    
    img.src = imageSrc;
  };

  const drawDiffOverlays = (ctx: CanvasRenderingContext2D, docIndex: number) => {
    diffList.forEach(diff => {
      if (diff.diff && diff.diff.length > 0) {
        diff.diff.forEach(charGroup => {
          charGroup.forEach(charInfo => {
            if (charInfo.doc_index === docIndex && charInfo.char_polygons) {
              charInfo.char_polygons.forEach(polygon => {
                const [x, y, x2, y2] = polygon;
                
                // 设置半透明填充色
                ctx.fillStyle = `${statusColors[diff.status]}40`; // 添加透明度
                ctx.fillRect(x, y, x2 - x, y2 - y);
                
                // 设置边框色
                ctx.strokeStyle = statusColors[diff.status];
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, x2 - x, y2 - y);
              });
            }
          });
        });
      }
    });
  };

  const handleDiffClick = (diff: DiffItem) => {
    setSelectedDiff(diff);
    // 可以添加滚动到对应位置的逻辑
  };

  return (
    <div className="diff-viewer">
      {/* 差异统计 */}
      <Card className="summary-card" style={{ marginBottom: 16 }}>
        <Row gutter={16}>
          <Col span={6}>
            <div className="stat-item">
              <Text strong>总差异数</Text>
              <div className="stat-number">{summary.total_differences}</div>
            </div>
          </Col>
          <Col span={6}>
            <div className="stat-item">
              <Text strong>新增</Text>
              <div className="stat-number" style={{ color: statusColors.ADD }}>
                {summary.additions}
              </div>
            </div>
          </Col>
          <Col span={6}>
            <div className="stat-item">
              <Text strong>删除</Text>
              <div className="stat-number" style={{ color: statusColors.DELETE }}>
                {summary.deletions}
              </div>
            </div>
          </Col>
          <Col span={6}>
            <div className="stat-item">
              <Text strong>修改</Text>
              <div className="stat-number" style={{ color: statusColors.CHANGE }}>
                {summary.changes}
              </div>
            </div>
          </Col>
        </Row>
      </Card>

      <Row gutter={16}>
        {/* 图片对比区域 */}
        <Col span={16}>
          <Row gutter={16}>
            <Col span={12}>
              <Card title="标准文档" size="small">
                <div className="image-container">
                  <canvas 
                    ref={standardCanvasRef}
                    style={{ maxWidth: '100%', height: 'auto' }}
                  />
                </div>
              </Card>
            </Col>
            <Col span={12}>
              <Card title="待审核文档" size="small">
                <div className="image-container">
                  <canvas 
                    ref={targetCanvasRef}
                    style={{ maxWidth: '100%', height: 'auto' }}
                  />
                </div>
              </Card>
            </Col>
          </Row>
        </Col>

        {/* 差异列表 */}
        <Col span={8}>
          <Card title="差异清单" size="small">
            <List
              size="small"
              dataSource={diffList}
              renderItem={(diff, index) => (
                <List.Item
                  className={`diff-item ${selectedDiff?.element_id === diff.element_id ? 'selected' : ''}`}
                  onClick={() => handleDiffClick(diff)}
                  style={{ cursor: 'pointer' }}
                >
                  <div className="diff-item-content">
                    <div className="diff-header">
                      <Tag color={statusColors[diff.status]}>
                        {statusLabels[diff.status]}
                      </Tag>
                      <Text type="secondary">#{index + 1}</Text>
                    </div>
                    <div className="diff-content">
                      <Text code>{diff.elements}</Text>
                    </div>
                    <div className="diff-meta">
                      <Text type="secondary">
                        页面 {diff.page_index + 1}
                      </Text>
                    </div>
                  </div>
                </List.Item>
              )}
            />
          </Card>
        </Col>
      </Row>

      {/* 差异详情 */}
      {selectedDiff && (
        <Card title="差异详情" style={{ marginTop: 16 }}>
          <div className="diff-detail">
            <Row gutter={16}>
              <Col span={12}>
                <Text strong>差异类型：</Text>
                <Tag color={statusColors[selectedDiff.status]}>
                  {statusLabels[selectedDiff.status]}
                </Tag>
              </Col>
              <Col span={12}>
                <Text strong>页面位置：</Text>
                <Text>第 {selectedDiff.page_index + 1} 页</Text>
              </Col>
            </Row>
            <div style={{ marginTop: 16 }}>
              <Text strong>差异内容：</Text>
              <div style={{ marginTop: 8 }}>
                <Text code>{selectedDiff.elements}</Text>
              </div>
            </div>
          </div>
        </Card>
      )}
    </div>
  );
};

export default DiffViewer;
```

#### 3.3 样式文件
```css
/* src/styles/DiffViewer.css */
.diff-viewer {
  padding: 16px;
}

.summary-card .stat-item {
  text-align: center;
}

.summary-card .stat-number {
  font-size: 24px;
  font-weight: bold;
  margin-top: 8px;
}

.image-container {
  text-align: center;
  border: 1px solid #d9d9d9;
  border-radius: 6px;
  padding: 8px;
  background: #fafafa;
}

.diff-item {
  border: 1px solid #f0f0f0;
  border-radius: 6px;
  margin-bottom: 8px;
  padding: 12px;
  transition: all 0.3s;
}

.diff-item:hover {
  border-color: #1890ff;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.diff-item.selected {
  border-color: #1890ff;
  background-color: #e6f7ff;
}

.diff-item-content {
  width: 100%;
}

.diff-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.diff-content {
  margin-bottom: 8px;
  word-break: break-all;
}

.diff-meta {
  font-size: 12px;
}

.diff-detail {
  padding: 16px;
  background: #fafafa;
  border-radius: 6px;
}
```

### 4. 状态管理

#### 4.1 Redux Store结构
```typescript
// src/store/index.ts
export const store = configureStore({
  reducer: {
    auth: authSlice.reducer,
    documents: documentSlice.reducer,
    comparisons: comparisonSlice.reducer,
    reviews: reviewSlice.reducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],
      },
    }),
});
```

#### 4.2 文档状态管理
```typescript
// src/store/documentSlice.ts
interface DocumentState {
  documents: Document[];
  loading: boolean;
  error: string | null;
  uploadProgress: Record<string, number>;
}

const documentSlice = createSlice({
  name: 'documents',
  initialState,
  reducers: {
    setLoading: (state, action) => {
      state.loading = action.payload;
    },
    setDocuments: (state, action) => {
      state.documents = action.payload;
    },
    addDocument: (state, action) => {
      state.documents.push(action.payload);
    },
    updateUploadProgress: (state, action) => {
      const { documentId, progress } = action.payload;
      state.uploadProgress[documentId] = progress;
    },
  },
});
```

## 部署架构 (Demo版本)

### 1. 简化部署方案
```yaml
# docker-compose.yml
version: '3.8'
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: contract_diff
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://postgres:password@postgres:5432/contract_diff
    volumes:
      - ./uploads:/app/uploads  # 本地文件存储
    depends_on:
      - postgres

  frontend:
    build: ./frontend
    ports:
      - "3000:3000"
    depends_on:
      - backend

volumes:
  postgres_data:
```

### 2. 本地开发环境
```bash
# 后端启动
cd backend
pip install -r requirements.txt
uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

# 前端启动
cd frontend
npm install
npm run dev
```

### 3. 文件存储结构
```
uploads/
├── documents/          # 原始文档存储
│   ├── standard/       # 标准文档
│   └── target/         # 待审核文档
├── images/             # 生成的图片
│   ├── standard/       # 标准文档图片
│   └── target/         # 待审核文档图片
└── temp/               # 临时文件
```

## 性能优化

### 1. 后端优化
- **数据库索引：** 为常用查询字段添加索引
- **连接池：** 使用SQLAlchemy连接池
- **缓存策略：** Redis缓存热点数据
- **异步处理：** 使用Celery处理耗时任务
- **文件压缩：** 大文件分块上传

### 2. 前端优化
- **代码分割：** 使用React.lazy()懒加载
- **图片优化：** WebP格式，懒加载
- **缓存策略：** 浏览器缓存，Service Worker
- **虚拟滚动：** 大列表性能优化
- **防抖节流：** 搜索和上传优化

## 安全考虑

### 1. 认证授权
- **JWT Token：** 无状态认证
- **RBAC：** 基于角色的访问控制
- **API限流：** 防止恶意请求
- **CORS配置：** 跨域请求控制

### 2. 数据安全
- **文件加密：** 敏感文件加密存储
- **SQL注入防护：** 使用ORM参数化查询
- **XSS防护：** 输入验证和输出转义
- **CSRF防护：** CSRF Token验证

## 监控与运维

### 1. 应用监控
- **健康检查：** /health端点
- **性能指标：** 响应时间、吞吐量
- **错误追踪：** Sentry集成
- **业务指标：** 用户活跃度、功能使用率

### 2. 日志管理
- **结构化日志：** JSON格式
- **日志级别：** DEBUG、INFO、WARN、ERROR
- **日志聚合：** ELK Stack
- **日志轮转：** 防止磁盘空间不足

